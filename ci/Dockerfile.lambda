FROM python:3.12-slim@sha256:31a416db24bd8ade7dac5fd5999ba6c234d7fa79d4add8781e95f41b187f4c9a

ENV PYTHONPATH "${PYTHONPATH}:/opt/python/lib/python3.12/site-packages"
ENV PYTHONDONTWRITEBYTECODE 1
ENV TASK_ROOT /app
ENV APP_VENV="${TASK_ROOT}/.venv"
ENV POETRY_HOME="/opt/poetry"
ENV POETRY_VERSION="1.7.1"
ENV POETRY_VIRTUALENVS_CREATE="false"
ENV PATH="${APP_VENV}/bin:${POETRY_HOME}/bin:$PATH"
ARG NEW_RELIC_ENABLED=false
ENV NEW_RELIC_ENABLED=${NEW_RELIC_ENABLED}
ENV APP_HANDLER=application.handler

RUN apt-get update \
 && apt-get install -y bash git libtool autoconf automake gcc g++ make libffi-dev unzip jo \
 && rm -rf /var/lib/apt/lists/*

RUN mkdir -p ${TASK_ROOT}
WORKDIR ${TASK_ROOT}

# Install poetry and isolate it in it's own venv
RUN python -m venv ${POETRY_HOME} \
    && ${POETRY_HOME}/bin/pip3 install poetry==${POETRY_VERSION} virtualenv==20.30.0

COPY pyproject.toml poetry.lock ${TASK_ROOT}/

RUN python -m venv ${APP_VENV} \
    && . ${APP_VENV}/bin/activate \
    && poetry install \
    && poetry add awslambdaric wheel

COPY . ${TASK_ROOT}/

RUN . ${APP_VENV}/bin/activate \
    && make generate-version-file

ENV PORT=6011

ARG GIT_SHA
ENV GIT_SHA ${GIT_SHA}

# (Optional) Add Lambda Runtime Interface Emulator and use a script in the ENTRYPOINT for simpler local runs
ADD https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie /usr/bin/aws-lambda-rie
COPY bin/entry.sh /
COPY bin/sync_lambda_envs.sh /
RUN chmod 755 /usr/bin/aws-lambda-rie /entry.sh /sync_lambda_envs.sh

# Decide handler based on NEW_RELIC_ENABLED and optionally extract New Relic layer
RUN if [ "${NEW_RELIC_ENABLED}" = "true" ] || [ "${NEW_RELIC_ENABLED}" = "TRUE" ]; then \
        export APP_HANDLER=newrelic_lambda_wrapper.handler; \
        echo "NEW_RELIC_ENABLED=${NEW_RELIC_ENABLED} -> handler=${APP_HANDLER} (extracting NR layer)"; \
        unzip newrelic-layer.zip -d /opt; \
    else \
        export APP_HANDLER=application.handler; \
        echo "NEW_RELIC_ENABLED=${NEW_RELIC_ENABLED} -> handler=${APP_HANDLER} (skipping NR layer)"; \
    fi; \
    rm -f newrelic-layer.zip; \
    echo "FINAL_APP_HANDLER=${APP_HANDLER}" > /app/handler_meta

# Generate a wrapper entrypoint that bakes the resolved APP_HANDLER at build time (validation not needed; derived from boolean NEW_RELIC_ENABLED)
RUN APP_HANDLER=$(grep '^FINAL_APP_HANDLER=' /app/handler_meta | cut -d '=' -f2-) && \
    printf '#!/bin/sh\nexec /entry.sh %s\n' "${APP_HANDLER}" > /handler_entry.sh && \
    chmod +x /handler_entry.sh && \
    echo "Baked APP_HANDLER=${APP_HANDLER}"

ENTRYPOINT [ "/handler_entry.sh" ]